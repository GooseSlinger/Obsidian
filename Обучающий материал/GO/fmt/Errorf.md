# Справочник по `fmt.Errorf` и работе с ошибками в Go

Компактная шпаргалка по созданию, оборачиванию и проверке ошибок.  
Фокус: `fmt.Errorf`, `%w`, `errors.Is/As/Unwrap/Join`, слои (repo/service/handler), анти-паттерны.

---

## 1) Базовые способы создать ошибку

~~~go
var ErrNotFound = errors.New("not found")   // sentinel (переменная для Is)

err1 := errors.New("plain error")           // без форматирования
err2 := fmt.Errorf("cannot open: %s", name) // форматирование без обёртки
~~~

Когда нужен `errors.New`: простая константная ошибка.  
Когда `fmt.Errorf`: нужен форматированный текст **без** сохранения первопричины.

---

## 2) Обёртка первопричины через `%w` (главное про `fmt.Errorf`)

~~~go
base := ErrNotFound
err  := fmt.Errorf("repo get user: %w", base) // сохраняем цепочку причин
~~~

**Правила `%w`:**
1. Работает **только** в `fmt.Errorf`.
2. Разрешён **ровно один** `%w` в строке формата.
3. Аргумент для `%w` — обязательно `error`.
4. В `Printf`/`Sprintf` `%w` не работает → получите диагностический `%!w(...)`.

**Зачем оборачивать:** добавляем контекст *что делали*, сохраняя возможность наверху понять *почему упало*.

---

## 3) Проверка ошибок: `errors.Is` и `errors.As`

~~~go
// Is — проверяем по цепочке совпадение с sentinel
if errors.Is(err, ErrNotFound) {
    // handle 404
}

// As — разворачиваем до конкретного типа и читаем поля
var pathErr *os.PathError
if errors.As(err, &pathErr) {
    log.Printf("op=%s path=%s", pathErr.Op, pathErr.Path)
}
~~~

**Когда Is:** есть «маячок» (sentinel) и нужно понять «это она или нет».  
**Когда As:** важны поля типовой ошибки, а не только факт совпадения.